//! Business logic for creating and manipulating conversations.

use crate::models::{
    Conversation, ConversationDetail, CreateConversation, Message, MessageRow, NewMessage,
};
use crate::services::ollama::OllamaService;
use sqlx::PgPool;
use std::error::Error;
use uuid::Uuid;

/// Provides high level operations on conversations and their messages.
#[derive(Clone)]
pub struct ConversationService {
    pool: PgPool,
    ollama: OllamaService,
}

impl ConversationService {
    /// Create a new `ConversationService` with the given database pool and Ollama client.
    pub fn new(pool: PgPool, ollama: OllamaService) -> Self {
        Self { pool, ollama }
    }

    /// Insert a new conversation for the given user.
    pub async fn create_conversation(
        &self,
        user_id: Uuid,
        payload: &CreateConversation,
    ) -> Result<Conversation, sqlx::Error> {
        let model = payload
            .model
            .clone()
            .unwrap_or_else(|| crate::models::DEFAULT_MODEL.to_string());

        sqlx::query_as::<_, Conversation>(
            "INSERT INTO conversations (user_id, title, system_prompt, model) VALUES ($1, COALESCE($2, 'Nouvelle conversation'), COALESCE($3, ''), $4) RETURNING *",
        )
        .bind(user_id)
        .bind(&payload.title)
        .bind(&payload.system_prompt)
        .bind(&model)
        .fetch_one(&self.pool)
        .await
    }

    /// Retrieve all conversations owned by a specific user.
    pub async fn list_conversations(
        &self,
        user_id: Uuid,
    ) -> Result<Vec<Conversation>, sqlx::Error> {
        sqlx::query_as::<_, Conversation>(
            "SELECT * FROM conversations WHERE user_id = $1 ORDER BY created_at DESC",
        )
        .bind(user_id)
        .fetch_all(&self.pool)
        .await
    }

    /// Fetch one conversation and its messages if it belongs to the user.
    pub async fn get_conversation_detail(
        &self,
        user_id: Uuid,
        conv_id: Uuid,
    ) -> Result<Option<ConversationDetail>, sqlx::Error> {
        let conversation = sqlx::query_as::<_, Conversation>(
            "SELECT * FROM conversations WHERE id = $1 AND user_id = $2",
        )
        .bind(conv_id)
        .bind(user_id)
        .fetch_optional(&self.pool)
        .await?;

        if let Some(conv) = conversation {
            let messages = sqlx::query_as::<_, MessageRow>(
                "SELECT * FROM messages WHERE conversation_id = $1 ORDER BY created_at ASC",
            )
            .bind(conv.id)
            .fetch_all(&self.pool)
            .await
            .unwrap_or_default();

            Ok(Some(ConversationDetail {
                conversation: conv,
                messages,
            }))
        } else {
            Ok(None)
        }
    }

    /// Delete a conversation. Returns `true` if something was removed.
    pub async fn delete_conversation(
        &self,
        user_id: Uuid,
        conv_id: Uuid,
    ) -> Result<bool, sqlx::Error> {
        let result = sqlx::query("DELETE FROM conversations WHERE id = $1 AND user_id = $2")
            .bind(conv_id)
            .bind(user_id)
            .execute(&self.pool)
            .await?;

        Ok(result.rows_affected() > 0)
    }

    /// Add a user message and append the assistant reply generated by Ollama.
    pub async fn add_message(
        &self,
        user_id: Uuid,
        conv_id: Uuid,
        new_msg: &NewMessage,
    ) -> Result<MessageRow, Box<dyn Error>> {
        let conv = sqlx::query_as::<_, Conversation>(
            "SELECT * FROM conversations WHERE id = $1 AND user_id = $2",
        )
        .bind(&conv_id)
        .bind(&user_id)
        .fetch_optional(&self.pool)
        .await?
        .ok_or("conversation not found")?;

        sqlx::query(
            "INSERT INTO messages (conversation_id, sender_role, content) VALUES ($1, $2, $3)",
        )
        .bind(&conv_id)
        .bind(&new_msg.role)
        .bind(&new_msg.content)
        .execute(&self.pool)
        .await?;

        let mut history: Vec<Message> = Vec::new();
        if !conv.system_prompt.is_empty() {
            history.push(Message {
                role: "system".to_string(),
                content: conv.system_prompt.clone(),
            });
        }

        let existing = sqlx::query_as::<_, MessageRow>(
            "SELECT * FROM messages WHERE conversation_id = $1 ORDER BY created_at ASC",
        )
        .bind(&conv_id)
        .fetch_all(&self.pool)
        .await?;

        for m in existing {
            history.push(Message {
                role: m.sender_role,
                content: m.content,
            });
        }

        let ai_result = self.ollama.chat(&conv.model, &history).await?;

        let assistant_content = ai_result
            .get("message")
            .and_then(|m| m.get("content"))
            .and_then(|v| v.as_str())
            .unwrap_or("");

        let assistant = sqlx::query_as::<_, MessageRow>(
            "INSERT INTO messages (conversation_id, sender_role, content) VALUES ($1, 'assistant', $2) RETURNING *",
        )
        .bind(&conv_id)
        .bind(assistant_content)
        .fetch_one(&self.pool)
        .await?;

        Ok(assistant)
    }

    /// List all messages for a conversation if it belongs to the user.
    pub async fn list_messages(
        &self,
        user_id: Uuid,
        conv_id: Uuid,
    ) -> Result<Option<Vec<MessageRow>>, sqlx::Error> {
        let exists = sqlx::query_scalar::<_, i64>(
            "SELECT 1 FROM conversations WHERE id = $1 AND user_id = $2",
        )
        .bind(&conv_id)
        .bind(&user_id)
        .fetch_optional(&self.pool)
        .await?
        .is_some();

        if !exists {
            return Ok(None);
        }

        let messages = sqlx::query_as::<_, MessageRow>(
            "SELECT * FROM messages WHERE conversation_id = $1 ORDER BY created_at ASC",
        )
        .bind(conv_id)
        .fetch_all(&self.pool)
        .await?;

        Ok(Some(messages))
    }
}
